# Content Descriptions

A Content Description is the fundamental unit of Indoctrinate's catalog. Every file discovered during scanning becomes a Content Description object containing identification, location, type information, labels, and optionally the file's content.

## Structure

```javascript
{
    // Identification
    UUID: '83853f9c-732c-4225-9a20-abcde47c6ddb',
    Type: 'URI',
    Hash: 'URI~CONTENT~FILE://path/to/file.md',

    // Location
    Path: 'FILE://path/to/file.md',
    Location: '/path/to',
    Name: 'file.md',

    // Type Information
    MimeType: 'text/markdown',
    Nature: 'text',
    Format: 'markdown',
    Schema: 'Default',

    // Content (loaded for special file types)
    Content: '# File Title\n\nContent here...',

    // Labels (auto-generated from path and name)
    Labels: [
        '__LABELSET_TYPE', 'FILE',
        '__LABELSET_ADDRESS', 'path', 'to',
        '__LABELSET_NAME', 'file',
        '__LABELSET_EXTENSION', '.md',
        '__LABELSET_FILENAME', 'file.md',
        '__LABELSET_FULLPATH', 'FILE://path/to/file.md',
        '__LABELSET_FORMAT', 'markdown', 'Default'
    ],

    // Extended data (added by processors)
    ExtendedContent: {
        MB_EXT: ['md'],
        MB_MIME: ['text/markdown']
    }
}
```

## Properties

### Identification

| Property | Type | Description |
|----------|------|-------------|
| `UUID` | string | Unique identifier generated by Fable's UUID service |
| `Type` | string | Address type, always `URI` for file-based content |
| `Hash` | string | Content hash in format `{Type}~CONTENT~{Path}` |

### Location

| Property | Type | Description |
|----------|------|-------------|
| `Path` | string | Full path with protocol prefix (`FILE://...`) |
| `Location` | string | Directory path (protocol prefix stripped) |
| `Name` | string | Filename only |

### Type Information

| Property | Type | Description |
|----------|------|-------------|
| `MimeType` | string | Full MIME type (e.g., `text/markdown`) |
| `Nature` | string | MIME type category (e.g., `text`, `application`, `image`) |
| `Format` | string | MIME subtype (e.g., `markdown`, `json`, `javascript`) |
| `Schema` | string | Special schema identifier for known file types |

### Schema Values

| Schema | Trigger | Description |
|--------|---------|-------------|
| `Default` | Any file | Standard file with no special handling |
| `PackageDotJSON` | `package.json` | Node.js package manifest; content is parsed JSON |
| `Indoctrinate-ExtraFolders` | `indoctrinate-extrafolders.json` | Adds extra scan directories |
| `Indoctrinate-Structure` | `indoctrinate-structure*.json` | Defines output structure |
| `Indoctrinate-Target` | `indoctrinate-target*.json` | Defines output target |

### Content Loading

Not all files have their content loaded into memory. Content is loaded for:

- **Markdown files** - Full text content loaded as a string
- **package.json** - Parsed as JSON
- **Indoctrinate directive files** - Parsed and acted upon during ingestion

For all other file types, `Content` is `false`. The file can still be read later during processing tasks.

### Extended Content

The `ExtendedContent` object is populated by processing tasks after initial cataloging. The default `UnderstandFile` task adds:

| Property | Description |
|----------|-------------|
| `MB_EXT` | Array of file extensions detected from magic bytes |
| `MB_MIME` | Array of MIME types detected from magic bytes |

Custom processing tasks can add additional data under their own keys.

## Creating Content Descriptions

Content descriptions are normally created automatically during scanning. The Ingestor service handles creation:

```javascript
// From a file path (used internally by the scanner)
let tmpDescription = fable.IndoctrinateIngestor.createContentDescriptionFromFile('/path/to/file.md');

// From a URI with explicit address type
let tmpDescription = fable.IndoctrinateIngestor.createContentDescription('FILE://path/to/file.md', 'URI');
```

## Accessing Content Descriptions

After compilation, content descriptions are stored in the catalog and accessible through filtering:

```javascript
// Get all markdown files
let tmpMarkdownFiles = fable.IndoctrinateServiceCatalog.gatherContentByFilterSet([
    { Type: 'Format', Format: 'markdown' }
]);

// Get all package.json files
let tmpPackageFiles = fable.IndoctrinateServiceCatalog.gatherContentByFilterSet([
    { Type: 'Schema', Schema: 'PackageDotJSON' }
]);

// Get files matching specific labels
let tmpApiDocs = fable.IndoctrinateServiceCatalog.gatherContentByFilterSet([
    { Type: 'Label', Labels: ['doc', 'api'], MatchAll: true, Sequential: true, Proximal: true }
]);
```

## Best Practices

1. **Check the Format property** for content type, not the file extension
2. **Use Schema filtering** for known special file types like `package.json`
3. **Use Label filtering** for content selection based on location and naming
4. **Access Content directly** for markdown files; use file I/O for binary types
5. **Extend through ExtendedContent** when adding custom metadata in processing tasks
